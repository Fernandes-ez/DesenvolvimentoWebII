'use strict';

var utils = require('./utils');

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    duplicates: 'combine',
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the âœ“ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the âœ“ character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('âœ“')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };

    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        var existing = has.call(obj, key);
        if (existing && options.duplicates === 'combine') {
            obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === 'last') {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))
                ? []
                : [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
            var index = parseInt(decodedRoot, 10);
            if (!options.parseArrays && decodedRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== decodedRoot
                && String(index) === decodedRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (decodedRoot !== '__proto__') {
                obj[decodedRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, check strictDepth option for throw, else just add whatever is left

    if (segment) {
        if (options.strictDepth === true) {
            throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
        }
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    var duplicates = typeof opts.duplicates === 'u » °°°©©ºª» š°»¹¹°°ººº°«°°š««›» ° «°« ¹
» 
  ›» º»
  »°°   °          —°º   —š  °  °—š›° 
 °– ©°ª  v¨šš° °€vyˆ‹‹ `vw™™	« pvw™›«»°€v†™° °‡†™¹˜»
«€ˆ¨©  ª€                        D@
 ˆ PÂ€¡Êï*DàH‡‡†²ÄL€§&2ƒQkòÊ‘€FOfS¬ìH=@
DV("Ğ£AfZAµ¢QB”DŠzû¨x€”úB	S,° Ô¬í"pñöíğÄTØH/Â,1\x`!ˆ6„K
6ˆQôê.Gûìis8z|ú0A¿ªî|Y‡ı­ktæ·\øRDé]²Á¼ËÊ4¢a1Hwíìñ8a4»nDÁ»‚İi
×iÔ"öİü;cs€‡r€áèŠj!ÁB(8&ªŸ’\°Ş°©C´DbD$]á{ $ÊIE*ìLÕ`Ñ`àËæÌ 9\²°_R›ˆùÄ‘üœp¾LÏÃ3‚Sûå=èOş<8CIç§¥óÑÍY5ìKçG:5§Z+Sè„ı3r„z±Š=÷–ˆ8›ô¦¾ªh´W@ÔŞv«¡Å"Ãôø—E6¡LÖ ‡ËÀû
·íDÊ)w‘2ˆN—„§‚ÆLb©M
F<Å‹-Úv^¤˜#IÓX¤Â€UøìLxJŠn7«äÆKÑ²Eé
‹©€HK B0P
À‚$<{)¿ƒoáÛ,8Z	xÉÿv$“‡73`	"C~Noœ‘¯W|©]TÛÌ—PcÀ0!‚_²FF1USl'üöĞË8ş<÷RDäü/Ñ-à†ğî…ÓA:“@~‹;&~… Ç8	´O†Ù*|hÊQ…fro³RÉrØ¥5Z™FØn6ËŠ;~kl«R‰‚d–A€L£aÏ¶¡(sØ½s;ª©·äüÍ~Q/“ "€ªZí ô£'R	¤Ç&Š¬—¨ùŠÏr¿`Êh¢eÁÍµš
¨RW®Lˆ–$s)ùÛ[Ä‚!·èê#ZÍOö1'€'¸'d!3
0èÂfX2AÛÚÍrIğQ¤föo.Bf=\Ñ
A¢óEY¥j§åE›>ÉÿJ)ÂÓ¥h˜xÚhVvôleÄ8§B4ƒspÍ­sğÁ^“¿Â‰>°ôĞ›-%	 Ûí%¢D×À9Oø¦|u.ÃSïL'NFL"£°5³õê*‰Ó§´,ÂŸf,¶ƒ ‚1œB’Ä@C{÷Äàªÿ\°ù Âù'í™Ku°w@Ì5¿&Îi»ç–ËÿÜî´œ ™2˜(nù]ÃZ…pÓ˜ÛiƒA¬Âzæ$0ô1(²‚„®Š0Mò$„Ó „;´”Bê,†¶´Fáä‹9|ûh¾"0mÒ*áÖ&îWÕ(ZD–DÎÚP8Ú°¸ŠØYÿ½Œ’‘{¸\u6è•rR9¸$Vçb¨6L±"”ëÎp„!¢¦ìª1S€ÄàXƒ[ª#añ‰KáOÕ„[f½®5n.ÿÂ¡Õé:%âLÇo^›"ƒuc°T®Šøæª†R‘¢Ñ†ÃVJQÜÛr™M[Y)¡¦¦7A	ª‘4úº2)d²ÕcĞ•ı
u	Ÿ-¦ 8òí`2¦„BKCŒÄ•3ˆHT	.¢<yŸU>ŠÄÔÛ"ßœr}l5 m57Y‡BLÂ3\aú&,©ps!ò¹HŒÙˆY*×…
\¨MØ‘9ã,Âmx¼:b{ªÚ
ËÑ%xı6–RHDó¾-ÜS|AE\MÍHLj`ØnÌŞ’íâóÍ3¸Eo¶B
õ§JµıØY* ª‘pl±jãØCæxÕı‰ÛbäˆÛÉÍ3‰2’yVí,±fÂV€³mJ‹àz¸24ş:ÎàyÚşĞ«ğ$ øZ™X2Æ1Ja² 7¯ ù3 Õ½¤¤Ò~ –Şæ CÆi‡5Dj÷£(A:f€(Ù|ºÊıM•-DÄii©Ø fÁ’œùmxÚq9è©Õà8qE8à‚ÑhÁO<x!u&Kc’çÅHğ4€†¤ÉØ“·Ä**5…zyV#ˆG;•º¤iÔ^}ß{ªe¯ºÑ©{ó{ĞsRŒ9FöÖ·uV~è¯~“eè«\ù)Ç²òjšşŒ¢{]õà_åÑ$yªó`6±~ıÙÇ^õí¾Fmß˜©¹õäù(.«å·ò¯o¨™ûĞ½J´ uÜ N{¾–$$W¦ëşì1 kŞöfo—‡u†BFó¤†Öó¨1Ÿ¶y¨”k’\wÕ$FOyEÎ¶cøš|Òh\”_Çùšÿ>äàÿìÎ}>¡xn^{!Ç9ï[oéñnúE³~îS‡ûÉ.:”ËûÈ]ºSgÒ×>ûÒ^Õâ›:gaOéÏõİ.]Òg4éşE¬^õ¿œË¿èÕîúç=ö¤Z§?¼øY‡ÔÈuNòSúy²CïäGõÉwÜEõ˜ß>rèu¾ï,û§hµ èôç?^¡	µFt‘õÊ1àÛÊ¤0‡' Ö½A[ƒö@ºÂÎ~|øË†5h ãoÈ™cPÔ?0à/ÅòÏsëÿ¥¡œCWBàÖğåya«èÈpˆ)q² Œ‹€Œ&¹¤mËXÅ•=[jƒñÅC^ep“"Pákvl—èóChÆPÚA¥bÊµ-S®Èv’ ä&w%@wpîËcöş§ˆéƒ’{§ÎÁ›
êh×Ğ–’m`@#}Õx#Î«²_Paèx[œğ)aw}0Ó™9æ—ü¨•ÓÏ}Ö¿>ì¨Ïip§´b!õ–ñn¹¦Uhì7
†³cÜœöAÄ)9Ì¯mÛÓªÛ„q)@†bÆfªVı¬¶¾c cØöÔ#€ÀÙ(¨P°*l	İñ1>_3S\ìçVZb¡cg+ålÈÚ#ÁW
óà[â*øqÜWK¢©…'¦4$·a*’ŸÌ=ç|*á1å²tzZï†Ÿk©ŠçÑs+M€dÎ0q[([ÆW#•ªyÓ»4.ƒYŠ™ZyÕ®1Gƒÿ÷Õ"üŒ¼”+rØZ!¹ûÂ»}IB>Ò2æ.ĞL÷N^¡`bÃv"¼Ì X ‰a€I‚U¯¢ !üD¯¤'XôNj§TqŠí¦$°ço©¬[zÉ»$ÌèØñPjË&bf‘Ìò­ıG]ğ‰ÈüzşÀñGá÷Ÿ8Ã„d‰ƒGÎ‹Lvf´!À+ÈZşımú®h<Y`ëåeeÃ‹	›ªS™›—mZ˜øLYBã^  ”™™š©	©ª¹¹	©¹ š
–«›»ºº›		›¹°ª¨‰x‡x˜˜ˆ©™y™ˆˆ‰ªº
™yxg‡h€‡f—g†˜y¹‹¶š›¹
©º¨ º¹©š™›»©
›¹º¹º©«›¨™›¸«˜©¹ª°©¹ 
›˜™››™š™˜»º º»°{¹	°     
       •      vx–°° °°wx˜›Š ¸ †‰‰»«°ˆ‰˜«  ‡x™››
 ‹†ˆ‰º° ‹‡‡‹ª° p‡§™ª
°‹ˆ¸¹»°  »                               P`@£ ¡@"`f¨P)Ÿ ©ûKÁ…2Áéä2%8.,:€z 8˜~ B‚æÔç¹,(@˜½R€á$Ä ©GqS ¢˜:<”q?İtñW¦.Ş@| ÷™úNZpsy•X˜ ¥ƒ &